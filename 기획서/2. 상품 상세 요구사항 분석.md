# 2. 상품 상세

## 요구사항 분석

### 화면 요약
- 리뉴얼이 가장 많이되는 화면
- UI가 v1 -> v2로 변경되면 api가 다시 나와야 할 것이다. 백엔드에서 재활용 가능한 방법을 고민
  - 상품 상세에 고정적으로 들어간다고 판단되는 부분과 아닌 부분을 나눠서 controller에서 조합
  - UI의 고정된 부분과 아닌 부분을 나눠서 처리
- 현재 화면에서 나타내야하는 정보
  - 상품 정보(이미지, 이름, 설명, 가격), 리뷰와 별점, 쿠폰 조회 및 다운로드, 좋아요, 리뷰 조회, Q&A, 상품 상세 설명 정보
- API 엔드포인트는 유지보수 기간이 길어야 한다.
  - 앱같은 경우 엡 업데이트를 하지 않으면 구형 엔드포인트를 계속 호출함. 그렇기 때문에 변경에 민감하다고 가정
- 어디까지나 프론트엔드와 협의를 통해 구현되어야 하는 부분

### 도메인 분리
- 도메인을 나눌 범위
  - Product, Like, Review, Coupon, QnA
  - Like, Review, Coupon, QnA 신규 추가
- 도메인 분리의 이유?
  1. 각 도메인이 독립적인 의미를 가지는지 고민.
  2. 도메인 별로 생성/수정/삭제가 독립적으로 이루어 질 수 있는지
  3. 도메인의 변경이 다른 도메인에 영향을 끼치지 않는 범위를 지정
  4. 예를 들어, 상품 정보 수정이 일어나면 Review에 변화는 없음.
  5. + 추가확장에 열려있도록 구성 ex) Review에 이미지를 추가하고 싶다 -> Review 테이블에 imagePath만 추가해주면 됨
- Product는 핵심 도메인이고 Product를 중심으로 독립적으로 작용하는 테이블들이 존재하는 형태로 구성

### 상품 상세

#### 상품 상세 페이지가 요구하는 정보(v1)
상품 상세의 불변한 부분과 가변적인 부분을 판단하여 api를 나눠준다.
- 상품 정보(이미지, 이름, 설명, 가격), 리뷰와 별점, 쿠폰 조회 및 다운로드, 좋아요, 리뷰 조회, Q&A, 상품 상세 설명 정보
1. 상품 정보
   - 이미지: 이미지 경로를 담은 url - String
   - 이름: 상품의 이름 - String
   - 설명: 상품의 정보를 설명하는 글 - String
   - 가격: 상품의 가격 - BigDecimal
   - 상품 상세 설명: 이미지 혹은 HTML - String
2. 리뷰, 별점
   - 제목: 리뷰의 제목 - String
   - 설명: 리뷰를 설명하는 글 - String
   - 별점: 상품의 점수 - Enum(1~5)
   - 전체 리뷰를 로드하는 것은 과하기 때문에 5개만 로드함 -> 기준 미정
3. 좋아요
   - 좋아요 갯수: 상품과 1대1 대응하는 좋아요 갯수: Integer
   - 좋아요 여부: 클릭한 사용자가 좋아요를 눌렀는지 안눌렀는지 정보: Boolean
   - 추후 확장 가능성이 있다고 판단해서 도메인을 분리함
4. 쿠폰
   - 쿠폰명: 쿠폰 이름 - String
   - 할인율, 할인가: 할인율 or 할인가 - BigDecimal
   - 할인 타입: 퍼센트인지 정액인지 타입 정의 - enum(PERCENT, FIXED)
   - 유효 기간: 사용 가능기한 - LocalDateTime
5. QnA
   - 작성자(질문자): 질문을 작성한 사람의 정보 - User
   - 답변자(판매자): 질문에 답변한 사람의 정보 - User
   - 질문: 질문의 내용 - String
   - 답변: 답변의 내용 - String
   - 답변 여부: 답변자가 답변 했는지 안했는지 여부 - Boolean
   - 질문 작성 일시: 질문을 작성한 날짜 - LocalDateTime

### 추가적인 고민 내용
- 상품 상세에서의 데이터 조회 성능
  - 이 부분을 이전에 고민한 내용을 붙여보면 상품 상세 데이터가 쉽게 변할까?
  - 쉽게 변하지 않는 데이터는 캐싱을 통해서 성능 개선이 가능하다.
- API를 나누는 기준?
  - 나누는 기준이 여러가지. api 엔드포인트를 여러개 뺄 것인가
  - 하나의 엔드포인트에 여러 서비스들로 데이터를 가져올건가
  - 하나의 엔드포인트에 조인쿼리를 써서 한번에 데이터를 넣어줄건가
  - 2번을 선택 했고 이유는 다음과 같음
  - 1번은 프론트가 여러 api를 병렬 호출해서 네트워크 요청이 많다는 단점이 존재하고 ui응답 타이밍에 따라 로딩이 어려울 수 있음
  - 3번은 도메인의 경계가 다 허물어 지게 되고 다른 테이블의 구조 변경시 쿼리 자체가 수정되어야함. 확장도 어려울 뿐더러 책임이 명확하지 못함
  - 맨 처음 readme에서 정리했듯이 요구사항 변경이 잦음. 그렇기 때문에 도메인 별로 변경될 때 마다 수정이 잦다는 의미
  - 도메인의 경계를 유지하면서 내부적으로 유연하게 대처가 가능하다고 판단했음
  - 그리고 가장 큰 이유로는 경계가 확실하기 때문에 책임에 대한 분리가 명확하게 이루어 진다고 판단했음
  - 1번도 경계가 확실하지만 경계를 지키기위해 일어나는 트레이드 오프가 과하다고 판단했음 만약 상품상세에서 더 많은 데이터를 요구하면 api호출이 더 많아지기 때문






